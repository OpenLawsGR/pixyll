---
layout:     post
title:      Revised system architecture
date:       2016-10-17 08:45:00
summary:    The revised architecture of our system.
categories: legislation
---

In a [previous post]({{ site.baseurl }}/legislation/2015/08/30/Methodology/) we had presented a general layout of the methodology that we intended to follow. At that time, we wanted to implement a completely automatic system for the consolidation of Greek legislation. However, this proved to be impossible due to errors (e.g. syntax errors) found in the legislative texts. As a result, we had to revise the architecture of our system, adding one more step after that of structural analysis. In this step, we use a validator (parsing the xml documents used for the markup of law texts), which is able to detect xml files with wrong structure (e.g. elements missing or in wrong order). Then, there is a need for manual intervention and correction of these files. The revised architecture is shown below:

![Revised architecture]({{ site.baseurl }}/images/architecture.png)

When writing the [initial post]({{ site.baseurl }}/legislation/2015/08/30/Methodology/) about the methodology, only steps 1-4 were implemented. Now that system is at the last phase of development, it is a good chance to update the descriptions of the remaining steps:


__Structural Analysis:__ In order to automatically perform transformations to a law text based on a modification's content, it is necessary to be aware of the structure of each law. Modifications refer to structural elements (such as articles, paragraphs, sub-paragraphs etc.) that a reader can easily search and identify within the text. However, a machine needs to analyze the text, processing natural language, to recognize these elements.This module of our system parses each law text, performs structural analysis and identifies the structural elements. Laws' structure follows distinct patterns, in the sense that laws should be written according to the rules set by the Central Legislatorial Committee that explicitly define the structural parts of the text. The appropriate regular expressions match the patterns that occur according to these rules. Pattern matching is done recursively for each detected structural element, finding its children elements and the same process goes on. After the recognition of these elements, an XML file for each law is generated. The analysis stops at the level of paragraphs, as this is the first visited element that may contain modifications when traversing the structural hierarchy from top to bottom.

__Validation and Manual Editing:__ Law texts may contain grammar or syntax errors and misprints. Moreover, rules and patterns are not always followed by law makers and while we had reviewed and incorporated in our system many cases of informal patterns, it is practically impossible to cover the total set of them. Hence, these problems result in incorrect XML files. In order to detect these problematic files, an XML validator was implemented. The validator checks if the hierarchy of the structural elements is followed and validates the numbering sequence of the elements, as most faults result in erroneous sequence due to unsuccessful elements detection. Those files that do not pass validation need manual editing and corrections. 

__Identification and Automatic Application of Modifications:__ Modifications fell into three categories: addition, substitution or deletion of a text portion. In order to detect the patterns for these categories that should be transformed to regular expressions, we needed to identify the verbs that are used to declare each case, since they are usually the same or belong to a list of synonyms. For this purpose, we considered a random sample of 100 laws and using the Greek POS tagger from [AUEB Natural Language Processing Group](http://nlp.cs.aueb.gr/software.html), we created a frequency matrix of the verbs found in the sample that are in present tense and passive voice. The most frequently used verbs (e.g. is replaced, is added etc.) that semantically belong to the above categories, along with their synonyms, were used to form the appropriate regular expressions. Nineteen regular expressions were formed that capture successfully 96,1% (1.789 out of 1.861) of modifications existing in the sample. It is interesting that only three regular expressions are adequate to detect 85% of all successfully matched cases. Pattern matching occurs at the level of paragraphs, so paragraphs are distinguished in amending and non-amending. According to the regular expression that returns a match in each case, we are able to know in which place there is the necessary information to perform the modification: modification category, cited law, referenced element, text to add or replace or text to delete. These data are used to annotate modifications in the XML files. When all modifications are identified and annotated, a script traverses all lawsâ€™ XML files in a chronological order and transforms the appropriate XML nodes (elements) according to the actions defined in the detected modifications, creating new file revisions. As mentioned earlier, structural analysis stops at the level of paragraphs. When a modification requires changes in a lower level (e.g. passage or case), paragraphs are broken down in passages using the [Python NLTK suite](http://www.nltk.org/), which we trained using our sample corpus of 100 laws to get much better results.

__XSL Transformation and Push to Repository:__ In this last step the appropriate XSL transformations are applied to the XML files that represent laws revisions in order to generate user friendly text versions of them. These text revisions are then pushed in a [Github repository](https://github.com/OpenLawsGR/greek_laws_alpha), an alpha version of which is already publically available.


